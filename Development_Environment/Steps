1. Setup - using virtualenv_sublime_pycharm or django_folder_structure
2. super_user
3. app
4. models.py in app
5. settings.py in src
6. Migrate in terminal - python manage.py migrate
   this gives migration has changed but not applied. So it says models has changed but not pushed to DB for sync

7. So run - python manage.py makemigrations
8. again run - python manage.py migrate
this ll make sure db is in sync with the models.

9. Now adding models to admin

10. So open up admin.py to register your models

11. we need to run the server again - now after this if you go to admin url you can see posts there

12. Now add a post from admin. - This will add the post to database

13. Customization to django admin

14. CRUD with admin  - With database its INSERT, SELECT, UPDATE, DELETE
CRUD is also done on forms using POST,GET,PUT,DELETE  -- CUD requires permissions on views

15. Creating views for html contents. so we have things database.
Views.py - developing function based views

16. Now these views need to be rendered as url. So go urls.py to register the views in urls.py

17. create urls.py in posts. these includes all the urls for posts app. now we can include all these urls back in
    urls.py in blog

    so this is how it works - import views of polls app into urls.py of polls. so that it can list the urls for this
    specific apps views. and then we can import these urls into main app urls.py.

18. go to views.py to add crud operations

19. Next is setting up django templates.

BASE_DIR - Is the path where src is located. But its not hardcoded, hence uses OS path module to locate it. In Our case,

src = /home/kartik/PycharmProjects/django_blog

Now, make a folder inside src and add the path in settings.py -
in templates dir would be []. Add the path here as os.path.join(base_dir,'templates' )

if this path is not added then django cant locate the template to load.

20. template_context

add contexts to dictionaries in views.py and define what it is.

Use that in templates.

This is a dynamic way of linking the views in templates using {{}}.

you can also add context based on if user is authenticated. this works because i am still logged into admin.
if i logout this case doesnt work.

21. Query set basics:

Close the server and login to python shell as python manage.py shell - this allows to use python + django shell

this gives us the database interactions.

##
from posts.models import Post
Post.objects.all() - gives all the objects in database

##
we can filter things like this :
Post.objects.filter(title__icontains="" ) - icontains used is used to match the cases.

## create new content from database as

Post.objects.create(title='United',content='my club')

## Looping through

queryset = Post.objects.all()
for obj in queryset:
    print obj.title
    print obj.content


we can do the same in our controller - i.e in views.py and add the queryset attribute into context
and make changes in index template where you can view objects or loop through the objects.

22. get_object_or_404 call to views.py

23. dynamic routing - based on id  - take request and parameter as id and then do the service

24. Playing with urls - using the best url naming method among many
